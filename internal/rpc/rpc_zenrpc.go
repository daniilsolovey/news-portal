// Code generated by zenrpc v2.3.1; DO NOT EDIT.

package rpc

import (
	"context"
	"encoding/json"

	"github.com/vmkteam/zenrpc/v2"
	"github.com/vmkteam/zenrpc/v2/smd"
)

var RPC = struct {
	NewsService struct{ List, Count, ByID, Categories, Tags string }
}{
	NewsService: struct{ List, Count, ByID, Categories, Tags string }{
		List:       "list",
		Count:      "count",
		ByID:       "byid",
		Categories: "categories",
		Tags:       "tags",
	},
}

func (NewsService) SMD() smd.ServiceInfo {
	return smd.ServiceInfo{
		Methods: map[string]smd.Service{
			"List": {
				Description: `List retrieves news with optional filtering by tagId and categoryId, with pagination.
Returns NewsSummary (without content) sorted by publishedAt DESC.`,
				Parameters: []smd.JSONSchema{
					{
						Name:     "filter",
						Type:     smd.Object,
						TypeName: "NewsFilter",
						Properties: smd.PropertyList{
							{
								Name:        "tagId",
								Optional:    true,
								Description: `tagId optional tag filter`,
								Type:        smd.Integer,
							},
							{
								Name:        "categoryId",
								Optional:    true,
								Description: `categoryId optional category filter`,
								Type:        smd.Integer,
							},
							{
								Name:        "page",
								Optional:    true,
								Description: `page=1 page number (1-based)`,
								Type:        smd.Integer,
							},
							{
								Name:        "pageSize",
								Optional:    true,
								Description: `pageSize=10 items per page`,
								Type:        smd.Integer,
							},
						},
					},
				},
				Returns: smd.JSONSchema{
					Type:     smd.Array,
					TypeName: "[]NewsSummary",
					Items: map[string]string{
						"$ref": "#/definitions/NewsSummary",
					},
					Definitions: map[string]smd.Definition{
						"NewsSummary": {
							Type: "object",
							Properties: smd.PropertyList{
								{
									Name: "newsId",
									Type: smd.Integer,
								},
								{
									Name: "categoryId",
									Type: smd.Integer,
								},
								{
									Name: "title",
									Type: smd.String,
								},
								{
									Name: "author",
									Type: smd.String,
								},
								{
									Name: "publishedAt",
									Type: smd.String,
								},
								{
									Name: "category",
									Ref:  "#/definitions/Category",
									Type: smd.Object,
								},
								{
									Name: "tags",
									Type: smd.Array,
									Items: map[string]string{
										"$ref": "#/definitions/Tag",
									},
								},
							},
						},
						"Category": {
							Type: "object",
							Properties: smd.PropertyList{
								{
									Name: "categoryId",
									Type: smd.Integer,
								},
								{
									Name: "title",
									Type: smd.String,
								},
							},
						},
						"Tag": {
							Type: "object",
							Properties: smd.PropertyList{
								{
									Name: "tagId",
									Type: smd.Integer,
								},
								{
									Name: "title",
									Type: smd.String,
								},
								{
									Name: "statusId",
									Type: smd.Integer,
								},
							},
						},
					},
				},
				Errors: map[int]string{
					500: "internal server error",
				},
			},
			"Count": {
				Description: `Count returns the count of news matching the optional tagId and categoryId filters.`,
				Parameters: []smd.JSONSchema{
					{
						Name:     "filter",
						Type:     smd.Object,
						TypeName: "NewsFilter",
						Properties: smd.PropertyList{
							{
								Name:        "tagId",
								Optional:    true,
								Description: `tagId optional tag filter`,
								Type:        smd.Integer,
							},
							{
								Name:        "categoryId",
								Optional:    true,
								Description: `categoryId optional category filter`,
								Type:        smd.Integer,
							},
							{
								Name:        "page",
								Optional:    true,
								Description: `page=1 page number (1-based)`,
								Type:        smd.Integer,
							},
							{
								Name:        "pageSize",
								Optional:    true,
								Description: `pageSize=10 items per page`,
								Type:        smd.Integer,
							},
						},
					},
				},
				Returns: smd.JSONSchema{
					Description: `count of news items`,
					Type:        smd.Integer,
				},
				Errors: map[int]string{
					500: "internal server error",
				},
			},
			"ByID": {
				Description: `ByID retrieves a single news item by ID with full content, category and tags.`,
				Parameters: []smd.JSONSchema{
					{
						Name:        "id",
						Description: `news numeric ID`,
						Type:        smd.Integer,
					},
				},
				Returns: smd.JSONSchema{
					Optional: true,
					Type:     smd.Object,
					TypeName: "News",
					Properties: smd.PropertyList{
						{
							Name: "newsId",
							Type: smd.Integer,
						},
						{
							Name: "categoryId",
							Type: smd.Integer,
						},
						{
							Name: "title",
							Type: smd.String,
						},
						{
							Name: "content",
							Type: smd.String,
						},
						{
							Name: "author",
							Type: smd.String,
						},
						{
							Name: "publishedAt",
							Type: smd.String,
						},
						{
							Name: "category",
							Ref:  "#/definitions/Category",
							Type: smd.Object,
						},
						{
							Name: "tags",
							Type: smd.Array,
							Items: map[string]string{
								"$ref": "#/definitions/Tag",
							},
						},
					},
					Definitions: map[string]smd.Definition{
						"Category": {
							Type: "object",
							Properties: smd.PropertyList{
								{
									Name: "categoryId",
									Type: smd.Integer,
								},
								{
									Name: "title",
									Type: smd.String,
								},
							},
						},
						"Tag": {
							Type: "object",
							Properties: smd.PropertyList{
								{
									Name: "tagId",
									Type: smd.Integer,
								},
								{
									Name: "title",
									Type: smd.String,
								},
								{
									Name: "statusId",
									Type: smd.Integer,
								},
							},
						},
					},
				},
				Errors: map[int]string{
					400: "id must be positive",
					404: "news not found",
					500: "internal server error",
				},
			},
			"Categories": {
				Description: `Categories retrieves all categories ordered by orderNumber.`,
				Parameters:  []smd.JSONSchema{},
				Returns: smd.JSONSchema{
					Type:     smd.Array,
					TypeName: "[]Category",
					Items: map[string]string{
						"$ref": "#/definitions/Category",
					},
					Definitions: map[string]smd.Definition{
						"Category": {
							Type: "object",
							Properties: smd.PropertyList{
								{
									Name: "categoryId",
									Type: smd.Integer,
								},
								{
									Name: "title",
									Type: smd.String,
								},
							},
						},
					},
				},
				Errors: map[int]string{
					404: "categories not found",
					500: "internal server error",
				},
			},
			"Tags": {
				Description: `Tags retrieves all tags ordered by title.`,
				Parameters:  []smd.JSONSchema{},
				Returns: smd.JSONSchema{
					Type:     smd.Array,
					TypeName: "[]Tag",
					Items: map[string]string{
						"$ref": "#/definitions/Tag",
					},
					Definitions: map[string]smd.Definition{
						"Tag": {
							Type: "object",
							Properties: smd.PropertyList{
								{
									Name: "tagId",
									Type: smd.Integer,
								},
								{
									Name: "title",
									Type: smd.String,
								},
								{
									Name: "statusId",
									Type: smd.Integer,
								},
							},
						},
					},
				},
				Errors: map[int]string{
					404: "tags not found",
					500: "internal server error",
				},
			},
		},
	}
}

// Invoke is as generated code from zenrpc cmd
func (s NewsService) Invoke(ctx context.Context, method string, params json.RawMessage) zenrpc.Response {
	resp := zenrpc.Response{}
	var err error

	switch method {
	case RPC.NewsService.List:
		var args = struct {
			Filter NewsFilter `json:"filter"`
		}{}

		if zenrpc.IsArray(params) {
			if params, err = zenrpc.ConvertToObject([]string{"filter"}, params); err != nil {
				return zenrpc.NewResponseError(nil, zenrpc.InvalidParams, "", err.Error())
			}
		}

		if len(params) > 0 {
			if err := json.Unmarshal(params, &args); err != nil {
				return zenrpc.NewResponseError(nil, zenrpc.InvalidParams, "", err.Error())
			}
		}

		resp.Set(s.List(ctx, args.Filter))

	case RPC.NewsService.Count:
		var args = struct {
			Filter NewsFilter `json:"filter"`
		}{}

		if zenrpc.IsArray(params) {
			if params, err = zenrpc.ConvertToObject([]string{"filter"}, params); err != nil {
				return zenrpc.NewResponseError(nil, zenrpc.InvalidParams, "", err.Error())
			}
		}

		if len(params) > 0 {
			if err := json.Unmarshal(params, &args); err != nil {
				return zenrpc.NewResponseError(nil, zenrpc.InvalidParams, "", err.Error())
			}
		}

		resp.Set(s.Count(ctx, args.Filter))

	case RPC.NewsService.ByID:
		var args = struct {
			Id int `json:"id"`
		}{}

		if zenrpc.IsArray(params) {
			if params, err = zenrpc.ConvertToObject([]string{"id"}, params); err != nil {
				return zenrpc.NewResponseError(nil, zenrpc.InvalidParams, "", err.Error())
			}
		}

		if len(params) > 0 {
			if err := json.Unmarshal(params, &args); err != nil {
				return zenrpc.NewResponseError(nil, zenrpc.InvalidParams, "", err.Error())
			}
		}

		resp.Set(s.ByID(ctx, args.Id))

	case RPC.NewsService.Categories:
		resp.Set(s.Categories(ctx))

	case RPC.NewsService.Tags:
		resp.Set(s.Tags(ctx))

	default:
		resp = zenrpc.NewResponseError(nil, zenrpc.MethodNotFound, "", nil)
	}

	return resp
}
